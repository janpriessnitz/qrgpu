// CUDA rhypot function!!

#include <cuda_runtime.h>
#include <cmath>
#include <cstdio>

#include "QRKernel.h"

#define POS(n, m, r, c) ((r)*(m) + c)
#define MAX_N 1024
#define BLOCKDIM_X 512


// What dimensions??
// blockDim = m/colBlocks
// blocks = colBlocks

// blockDim = n - c
// Applies Q^T on extended matrix A - matrix Q is not explicitly calculated
__global__ void house(double *A, int n, int m, int c, double *magX2_global) {
    int x = c + threadIdx.x + blockIdx.x*blockDim.x;

    double magv2 = 0;
    double magx = sqrt(*magX2_global);
    double oldVal = A[POS(n, m, c, c)];
    double newVal = oldVal - magx;
    magv2 = *magX2_global - oldVal*oldVal + newVal*newVal;
    double beta = -2/magv2;

    // CALCULATE R
    double AprimeX;

    // do a special case for v[c] which is x[c] - |x|
    AprimeX = A[POS(n, m, c, x)]*newVal;
    for (int i = c+1; i < n;  ++i) {
        AprimeX += A[POS(n, m, i, x)]*A[POS(n, m, i, c)];
    }


    double nextMagX2 = 0;
    // do a special case for v[c] which is x[c] - |x|
    A[POS(n, m, c, x)] = A[POS(n, m, c, x)] + beta*newVal*AprimeX;
    if (x > c) {
        for (int i = c+1; i < n; ++i) {
            A[POS(n, m, i, x)] = A[POS(n, m, i, x)] + beta*A[POS(n, m, i, c)]*AprimeX;
            nextMagX2 += A[POS(n, m, i, x)]*A[POS(n, m, i, x)];
        }
    }
    if (x == c + 1) {
        *magX2_global = nextMagX2;
    }
}

__global__ void MagX2(double *A, int rows, int col, int cols_extended, double *magX2_out) {
    int x = threadIdx.x;
    int dimX = blockDim.x;

    double __shared__ x_sum[BLOCKDIM_X];

    x_sum[x] = 0;
    for (int i = x+col; i < rows; i += dimX) {
        x_sum[x] += A[POS(rows, cols_extended, i, col)]*A[POS(rows, cols_extended, i, col)];
    }

    double magx2 = 0;
    // TODO: make it faster
    if (x == 0) {
        for (int i = 0; i < dimX; ++i) {
            magx2 += x_sum[i];
        }
        *magX2_out = magx2;
    }
}

__global__ void zeroLowerTriangular(double *A, int rows, int cols, int cols_extended) {
    int x = threadIdx.x;
    int dimX = blockDim.x;
    int blockX = blockIdx.x;
    int numBlocks = gridDim.x;
    for (int r = 0; r < rows; ++r) {
        for (int c = x; c < cols && c < r; c += dimX) {
            A[POS(rows, cols_extended, r, c)] = 0;
        }
    }
}

void QRSolve(double *A, int rows, int cols, int cols_extended) {
    int iters = cols;

    double *magX2;

    if (cudaMalloc((void**)&magX2, sizeof(magX2)) != cudaSuccess) {
      fprintf(stderr, "Device memory allocation error!\n");
      return;
    }

    MagX2<<<dim3(1), dim3(BLOCKDIM_X)>>>(A, rows, 0, cols_extended, magX2);
    for (int i = 0; i < iters; ++i) {
        house<<<dim3(1), dim3(cols_extended-i)>>>(A, rows, cols_extended, i, magX2);
    }
    zeroLowerTriangular<<<dim3(1), dim3(BLOCKDIM_X)>>>(A, rows, cols, cols_extended);
    cudaFree(magX2);
}



__global__ void copy(double *target, double *dest, int num) {
    int x = threadIdx.x;
    int dimX = blockDim.x;
    int blockX = blockIdx.x;
    int numBlocks = gridDim.x;

    for (int i = x + dimX*blockX; i < num; i += dimX*numBlocks) {
        if (i < num) {
            target[i] = dest[i];
        }
    }
}
