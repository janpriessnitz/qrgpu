// CUDA rhypot function!!

#include <cuda_runtime.h>
#include <cmath>
#include <cstdio>

#include "QRKernel.h"

#define POS(n, m, r, c) ((r)*(m) + c)
// POS but transposed
// #define POS(n, m, r, c) ((c)*(m) + r)

#define MAX_N 1024
#define BLOCKDIM_X 1024
#define BLOCKDIM_Y 16

#define BLOCKDIM_X_HOUSE 32


// What dimensions??
// blockDim = m/colBlocks
// blocks = colBlocks

// blockDim = n - c
// Applies Q^T on extended matrix A - matrix Q is not explicitly calculated
__global__ void house_vertical_block(double *A, int n, int m, int c, double *magX2_global) {
    int x = c + threadIdx.x + blockIdx.x*blockDim.x;
    int y = threadIdx.y;
    int dy = blockDim.y;

    double magv2 = 0;
    double magx = sqrt(*magX2_global);
    double oldVal = A[POS(n, m, c, c)];
    double newVal = oldVal - magx;
    magv2 = *magX2_global - oldVal*oldVal + newVal*newVal;
    double beta = -2/magv2;

    // CALCULATE R
    __shared__ double AprimeX[BLOCKDIM_Y];

    AprimeX[y] = 0;
    // do a special case for v[c] which is x[c] - |x|
    if (y == 0) {
        AprimeX[0] = A[POS(n, m, c, x)]*newVal;
    }
    for (int i = c+1+y; i < n; i += dy) {
        AprimeX[y] += A[POS(n, m, i, x)]*A[POS(n, m, i, c)];
    }

    // TODO: make it faster
    if (y == 0) {
        for (int i = 1; i < dy; ++i) {
            AprimeX[0] += AprimeX[y];
        }
    }


    __shared__ double nextMagX2[BLOCKDIM_Y];
    nextMagX2[y] = 0;
    // do a special case for v[c] which is x[c] - |x|
    if (y == 0) {
        A[POS(n, m, c, x)] = A[POS(n, m, c, x)] + beta*newVal*AprimeX[0];
    }
    if (x > c) {
        for (int i = c+1+y; i < n; i += dy) {
            A[POS(n, m, i, x)] = A[POS(n, m, i, x)] + beta*A[POS(n, m, i, c)]*AprimeX[0];
            if (x == c + 1) {
                nextMagX2[y] += A[POS(n, m, i, x)]*A[POS(n, m, i, x)];
            }
        }
    }
    if (x == c + 1) {
        if (y == 0) {
            for (int i = 0; i < dy; ++i) {
                nextMagX2[0] += nextMagX2[i];
            }
        }
        *magX2_global = nextMagX2[0];
    }
}

__global__ void house_horizontal_block(double *A, int n, int m, int c, double *magX2_in, double *magX2_out) {
    int x = c + threadIdx.x + blockIdx.x*blockDim.x;

    if (x >= m) return;

    double magv2 = 0;
    double magx = sqrt(*magX2_in);
    double oldVal = A[POS(n, m, c, c)];
    double newVal = oldVal - magx;
    magv2 = *magX2_in - oldVal*oldVal + newVal*newVal;
    double beta = -2/magv2;

    // CALCULATE R
    double AprimeX;

    // do a special case for v[c] which is x[c] - |x|
    AprimeX = A[POS(n, m, c, x)]*newVal;
    for (int i = c+1; i < n;  ++i) {
        AprimeX += A[POS(n, m, i, x)]*A[POS(n, m, i, c)];
    }


    double nextMagX2 = 0;
    // do a special case for v[c] which is x[c] - |x|
    A[POS(n, m, c, x)] = A[POS(n, m, c, x)] + beta*newVal*AprimeX;
    if (x > c) {
        for (int i = c+1; i < n; ++i) {
            A[POS(n, m, i, x)] = A[POS(n, m, i, x)] + beta*A[POS(n, m, i, c)]*AprimeX;
            nextMagX2 += A[POS(n, m, i, x)]*A[POS(n, m, i, x)];
        }
    }
    if (x == c + 1) {
        *magX2_out = nextMagX2;
    }
}


__global__ void MagX2(double *A, int rows, int col, int cols_extended, double *magX2_out) {
    int x = threadIdx.x;
    int dimX = blockDim.x;

    double __shared__ x_sum[BLOCKDIM_X];

    x_sum[x] = 0;
    for (int i = x+col; i < rows; i += dimX) {
        x_sum[x] += A[POS(rows, cols_extended, i, col)]*A[POS(rows, cols_extended, i, col)];
    }

    double magx2 = 0;
    // TODO: make it faster
    if (x == 0) {
        for (int i = 0; i < dimX; ++i) {
            magx2 += x_sum[i];
        }
        *magX2_out = magx2;
    }
}

__global__ void zeroLowerTriangular(double *A, int rows, int cols, int cols_extended) {
    int x = threadIdx.x;
    int dimX = blockDim.x;
    int blockX = blockIdx.x;
    int numBlocks = gridDim.x;
    for (int r = 0; r < rows; ++r) {
        for (int c = x; c < cols && c < r; c += dimX) {
            A[POS(rows, cols_extended, r, c)] = 0;
        }
    }
}

void QRSolve(double *A, int rows, int cols, int cols_extended) {
    int iters = cols;

    double *magX2;

    if (cudaMalloc((void**)&magX2, sizeof(magX2)*2) != cudaSuccess) {
      fprintf(stderr, "Device memory allocation error!\n");
      return;
    }

    MagX2<<<dim3(1), dim3(BLOCKDIM_X)>>>(A, rows, 0, cols_extended, magX2);
    for (int i = 0; i < iters; ++i) {
        // house_horizontal_block<<<dim3((cols_extended-i)/BLOCKDIM_X_HOUSE+1), dim3(BLOCKDIM_X_HOUSE)>>>(A, rows, cols_extended, i, magX2+(i%2), magX2+((i+1)%2));
        // house_horizontal_block<<<dim3(1), dim3(cols_extended-i)>>>(A, rows, cols_extended, i, magX2+(i%2), magX2+((i+1)%2));
        house_vertical_block<<<dim3(cols_extended-i, 1), dim3(1, BLOCKDIM_Y)>>>(A, rows, cols_extended, i, magX2);
    }
    zeroLowerTriangular<<<dim3(1), dim3(1, BLOCKDIM_X)>>>(A, rows, cols, cols_extended);
    cudaFree(magX2);
}



__global__ void copy(double *target, double *dest, int num) {
    int x = threadIdx.x;
    int dimX = blockDim.x;
    int blockX = blockIdx.x;
    int numBlocks = gridDim.x;

    for (int i = x + dimX*blockX; i < num; i += dimX*numBlocks) {
        if (i < num) {
            target[i] = dest[i];
        }
    }
}
